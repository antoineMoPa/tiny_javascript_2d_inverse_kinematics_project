<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Canvas Animation</title>
  <style>
    /* Minimal CSS normalization */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
    }

    canvas {
      display: block; /* Removes inline gap below the canvas */
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
  <canvas id="animationCanvas"></canvas>
  <script>
    const canvas = document.getElementById('animationCanvas');
    const ctx = canvas.getContext('2d');

    // Set canvas size to fill the screen
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas(); // Initial size setup

    const mouse = [0, 0];
    window.addEventListener('mousemove', (e) => {
        mouse[0] = e.clientX;
        mouse[1] = e.clientY;
    });

    const bones = [];

    function pinv(matrix) {
        return math.pinv(matrix); // Math.js pseudo-inverse
    }

    class Bone {
        parent = null;
        child = null;
        x = canvas.width / 2;
        y = canvas.height / 2;
        len = 100;
        angle = 0.4 * Math.PI;
        target = null;

        constructor() {
            bones.push(this);
        }

        setParent(parent) {
            this.parent = parent;
            parent.child = this;
        }

        applyConstraints() {
            if (this.parent) {
                this.x = this.parent.x + Math.cos(this.parent.angle) * this.parent.len;
                this.y = this.parent.y + Math.sin(this.parent.angle) * this.parent.len;
            }
        }

        selfTransformMatrix(deltaAngle = 0) {
            const c = Math.cos(this.angle + deltaAngle);
            const s = Math.sin(this.angle + deltaAngle);
            const x = this.len * c;
            const y = this.len * s;

            return [
                [c, -s, x],
                [s, c, y],
                [0, 0, 1]
            ];
        }

        transformMatrix(deltaAngle = 0) {
            const matrix = this.selfTransformMatrix(deltaAngle);
            const parentMatrix = this.parent
                ? this.parent.transformMatrix()
                : [[1, 0, this.x], [0, 1, this.y], [0, 0, 1]];
            return math.multiply(parentMatrix, matrix);
        }

        ik() {
            const MAX_IT = 20;
            for (let i = 0; i < MAX_IT; i++) {
                const matrices = [];
                const matricesPlusDelta = [];
                const matricesMinusDelta = [];
                const derivativeMatrix = [];

                let bone = this;

                while (bone) {
                    matrices.push(bone.transformMatrix());
                    const matrixPlusDelta = bone.transformMatrix(0.1);
                    const matrixMinusDelta = bone.transformMatrix(-0.1);
                    matricesPlusDelta.push(matrixPlusDelta);
                    matricesMinusDelta.push(matrixMinusDelta);
                    derivativeMatrix.push(math.subtract(matrixPlusDelta, matrixMinusDelta));
                    bone = bone.parent;
                }

                const jacobian = derivativeMatrix;
                const jacobianPinv = jacobian.map(m => pinv(m));
                const epsilon = 0.0001;
                const endEffectorMatrix = this.lastChild().transformMatrix();
                const endEffectorPosition = [endEffectorMatrix[0][2], endEffectorMatrix[1][2]];

                const error = math.subtract(this.target, endEffectorPosition);
                if (math.norm(error) < 2) {
                    break;
                }

                const deltaTheta = jacobianPinv.map(matrix => {
                    return matrix.map((row, rowIdx) => {
                        return row.reduce((sum, value, colIdx) => {
                            if (colIdx > 1) return sum;
                            return sum + value * error[colIdx];
                        }, 0);
                    });
                });

                let jointAngles = [];
                bone = this;
                while (bone) {
                    jointAngles.push(bone.angle);
                    bone = bone.parent;
                }

                jointAngles = jointAngles.map((angle, idx) => {
                    const adjustment = deltaTheta[idx].reduce((sum, value) => sum + value, 0);
                    return angle + adjustment * epsilon * Math.min(math.norm(error), 1);
                });

                bone = this;
                jointAngles.reverse();

                while (bone) {
                    bone.angle = jointAngles.pop() % (2 * Math.PI);
                    bone = bone.parent;
                }

                if (math.norm(error) < 2) {
                    break;
                }
            }
        }

        update() {
            this.applyConstraints();
        }

        drawFromMatrices() {
            ctx.beginPath();
            const parentTransform = this.parent ? this.parent.transformMatrix() : [[1, 0, this.x], [0, 1, this.y], [0, 0, 1]];
            const matrix = this.transformMatrix();
            const x1 = parentTransform[0][2];
            const y1 = parentTransform[1][2];
            const x2 = matrix[0][2];
            const y2 = matrix[1][2];

            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = 'white';
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(x1, y1, 5, 0, Math.PI * 2);
            ctx.fillStyle = 'red';
            ctx.fill();

            ctx.beginPath();
            ctx.arc(x2, y2, 5, 0, Math.PI * 2);
            ctx.fillStyle = 'blue';
            ctx.fill();
        }

        draw() {
            this.drawFromMatrices();
        }

        lastChild() {
            let bone = this;
            while (bone.child) {
                bone = bone.child;
            }
            return bone;
        }
    }

   const b1 = new Bone();
   b1.y = 100;


   let lastBone = b1;

   for (let i = 0; i < 30; i++) {
       const bone = new Bone();
       bone.len = 30;
       bone.setParent(lastBone);
       lastBone = bone;
   }

   function draw() {
       ctx.clearRect(0, 0, canvas.width, canvas.height);
       ctx.fillStyle = 'black';
       ctx.fillRect(0, 0, canvas.width, canvas.height);

       const lastBone = bones[bones.length - 1];
       lastBone.target = mouse;
       lastBone.ik();

       bones.forEach(b => b.update());
       bones.forEach(b => b.draw());

       ctx.beginPath();
       ctx.arc(mouse[0], mouse[1], 5, 0, Math.PI * 2);
       ctx.fillStyle = 'green';
       ctx.fill();

       requestAnimationFrame(draw);
   }

   draw();
  </script>
</body>
</html>
